<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HOR 2025 &ndash; 12th International Workshop on Higher-Order Rewriting</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            color: #333;
            background-color: #f9f9f9;
            font-size: 1rem;
        }
        .workshop-title {
            font-size: 2rem;
            font-weight: bold;
        }
        .workshop-subtitle {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .menu {
            margin: 0 auto;
            background: white;
            padding: 1rem;
            font-size: 1rem;
            text-align: center;
        }
        .menu a {
            color: #333;
            font-weight: bold;
            text-decoration: none;
        }
        .menu a:hover {
            color: lightblue;
        }
        header {
            background: #004080;
            color: white;
            text-align: center;
            padding: 1.5rem;
        }
        header a {
            color: white;
        }
        header a:hover {
            color: lightblue;
        }
        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
            background: white;
            box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 2rem;
        }
        h2 {
            color: #004080;
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }
        p {
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        .section {
            margin-bottom: 2rem;
        }
        footer {
            text-align: center;
            padding: 1rem;
            background: #004080;
            color: white;
            margin-top: 2rem;
        }
        footer a {
            color: white;
        }
        footer a:hover {
            color: lightblue;
        }
        .session {
            font-size: 1.25rem;
            padding: 1rem;
            background: #004080;
            color: white;
        }
        .break {
            font-size: 1.25rem;
            padding: 1rem;
            background: #808080;
            color: white;
        }
        .talk {
            border: solid black 1px;
            padding: 1rem 1rem 1rem 3rem;
        }
        .time {
            font-weight: bold;
        }
        .speaker {
            font-style: italic;
        }
        .title {
            font-weight: bold;
        }
        .abstract {
            display: none;
        }
        .show-abstract {
            font-size: .75rem;
        }
    </style>
    <script type="text/javascript">
function toggle(elem_id) {
    let elem = document.getElementById(elem_id);
    elem.style.display = elem.style.display !== 'block' ? 'block' : 'none';
}
    </script>
</head>
<body>

<header>
<span class="workshop-title">HOR 2025</span><br>
12th International Workshop on<br>
<span class="workshop-subtitle">Higher-Order Rewriting</span><br>
Birmingham, United Kingdom<br>
14th July, 2025<br>
affiliated with <a href="https://fscd2025.github.io/">FSCD 2025</a><br>
</header>

<div class="menu">
  <a href="#overview">Overview</a>
| <a href="#submission">Submission</a>
| <a href="#important-dates">Important dates</a>
| <a href="#invited-speakers">Invited speakers</a>
| <a href="#proceedings">Proceedings</a>
| <a href="#programme">Programme</a>
| <a href="#committees">Committees</a>
</div>

<div class="container">
    <div class="section">
        <h2><a name="overview">Overview</a></h2>
        <p><a href="https://hor.irif.fr">HOR</a> is a forum to present work concerning all aspects of
           higher-order rewriting. The aim is to provide an informal and friendly setting
           to discuss recent work and work in progress. The following is a non-exhaustive
           list of topics for the workshop:</p>
        <ul>
        <li> <strong>Applications:</strong>
             proof checking, theorem proving, generic programming, declarative programming, program transformation, automated
             termination/confluence/equivalence analysis tools.
        <li> <strong>Foundations:</strong>
             pattern matching, unification, strategies, narrowing, termination, syntactic properties,
             type theory, complexity of derivations.
        <li> <strong>Frameworks:</strong>
             term rewriting, conditional rewriting, graph rewriting, net rewriting, comparisons of different frameworks.
        <li> <strong>Implementation:</strong>
             explicit substitution, rewriting tools, compilation techniques.
        <li> <strong>Semantics:</strong>
             semantics of higher-order rewriting, categorical rewriting, higher-order abstract syntax, games and rewriting
		<li> <strong>Computing paradigms based on higher-order rewriting:</strong> lambda-calculi, higher-order logic
			programming, quantum programming languages, process calculi.
        </ul>
     Information about previous editions can be found <a href="https://hor.irif.fr">here</a>.

    </div>

    <div class="section">
        <h2><a name="submission">Submission</a></h2>
		<p>To give a presentation at the workshop, please submit an extended abstract (between 2 to <s>5 pages</s> <strong>7 pages (for the final version)</strong>) via Easychair:</p>
		<p><a href="https://easychair.org/conferences/?conf=hor2025">https://easychair.org/conferences/?conf=hor2025</a></p>
        <p>Please use LaTeX and the Easychair style to prepare your submission:</p>
        <p><a href="https://easychair.org/publications/easychair.zip">https://easychair.org/publications/easychair.zip</a></p>
		<p><a href="https://hor.irif.fr">HOR</a> is a platform for discussing open questions, ongoing research,
           and new perspectives, as well as new results. Extended abstracts describing
           work in progress, preliminary results, research projects, or problems in
           higher-order rewriting are very welcome. Specifically, short versions of
           recently published papers are welcome, and submission to HOR does not preclude
           formal publication at other venues.</p>
        <p>The workshop has informal electronic proceedings that will be made available on this website.</p>
        <p>For questions regarding submission, please contact the PC chair <a href="https://foones.github.io">Pablo Barenbaum</a>.</p>

    </div>

    <div class="section">
        <h2><a name="important-dates">Important dates</a></h2>
        <ul>
        <li> Submission deadline: <s>15 May, 2025</s> &ndash; extended: <strong>20 May, 2025</strong>
        <li> Notification: 6 June, 2025
        <li> Final version: 27 June, 2025
        <li> Workshop: 14 July, 2025
        </ul>
        All times are <a href="https://en.wikipedia.org/wiki/Anywhere_on_Earth">Anywhere on Earth</a>.
    </div>

    <div class="section">
        <h2><a name="invited-speakers">Invited speakers</a></h2>
        <ul>
        <li> <a href="https://lipn.univ-paris13.fr/~mazza/">Damiano Mazza</a> &ndash; CNRS, LIPN, Université Sorbonne Paris Nord, France
        <li> <a href="https://profiles.sussex.ac.uk/p624321-vincent-van-oostrom">Vincent van Oostrom</a> &ndash; University of Sussex, United Kingdom
        <li> <a href="https://theowinterhalter.github.io/">Théo Winterhalter</a> &ndash; INRIA Saclay, France
        </ul>
    </div>

    <div class="section">
        <h2><a name="proceedings">Proceedings</a></h2>
        <p>TBA</p>
    </div>

    <div class="section">
        <h2><a name="programme">Programme</a></h2>
        <div class="session">
          <span class="time">09:00&ndash;10:00</span> Session 1
        </div>
        <div class="talk">
          <span class="time">09:00</span>
          <span class="speaker">Kasper Hagens and Cynthia Kop</span><br>
          <span class="title">Higher-order inductive theorems via recursor templates</span>
          <a class="show-abstract "href="javascript:toggle('abstract1')">(Abstract)</a><br>
          <div id="abstract1" class="abstract">
<p>Rewriting Induction (RI) is a formal system in term rewriting for proving inductive theorems. Recently, RI has been extended to higher-order Logically Constrained Term Rewriting Systems (LCTRSs), which makes it an interesting tool for program verification with inductive theorems as an interpretation for program equivalence. A major challenge when proving inductive theorems with RI is the generation of suitable induction hypothesis, preferably automatically. Two existing heuristics often fail. Here, we consider another approach: rather than inventing new heuristics for proving individual cases, we consider classes of equivalences. This is achieved by introducing templates for detecting specific tail and non-tail recursive shapes. Whenever each of the two programs fit into such a template we can generate an equation which is guaranteed to be an inductive theorem.</p>
          </div>
        </div>
        <div class="talk">
          <span class="time">09:30</span>
          <span class="speaker">Alejandro Díaz-Caro, Octavio Malherbe and Rafael Romero</span><br>
          <span class="title">Basis-Sensitive Quantum Typing via Realizability</span>
          <a class="show-abstract "href="javascript:toggle('abstract2')">(Abstract)</a><br>
          <div id="abstract2" class="abstract">
<p>In most quantum programming languages, measurements are performed in the traditional computational basis. We present a work-in-progress where we dispose of this seemingly obvious choice and instead, we propose a quantum lambda-calculus where each lambda term is decorated with the basis in which it is to be measured.</p>
<p>This will allows to define a type system where terms which were previously treated linearly, are now treated in a classical fashion. This is done without having to rely on unitary gates to do so and thus, adding an abstraction layer between programs and circuitry. Another unexpected benefit was found designing the type system. We found that, when restricting the uncertainties to their extreme, we were left with a formal system for specification akin to Hoare logic.</p>
<p>In order to achieve this, we utilized the realizability technique to extract a lambda-calculus complete with its type system. We present the language and showcase a few examples.</p>
          </div>
        </div>
        <div class="break">
          <span class="time">10:00&ndash;10:30</span> Coffee Break
        </div>
        <div class="session">
          <span class="time">10:30&ndash;12:00</span> Session 2
        </div>
        <div class="talk">
          <span class="time">10:30</span>
          Invited talk: <span class="speaker">Théo Winterhalter</span><br>
          <span class="title">Controlling computation in type theory</span>
          <a class="show-abstract "href="javascript:toggle('abstract3')">(Abstract)</a><br>
          <div id="abstract3" class="abstract">
<p>I will present relatively recent work on extending the Agda and Rocq interactive theorem provers with user-defined rewrite rules. Such extensions come with their own set of challenges: unrestrained they break many expected meta-theoretical properties of the provers. I will explain how we addressed those challenges, focusing in particular on the verification of type preservation and confluence. I will then present a new proposal enabling the use of custom rewrite rules only locally to a definition (or a module) which opens interesting new possibilities for tools like Agda, Rocq, or the Dedukti logical framework.</p>
<p>This will include joint work with Jesper Cockx, Gaëtan Gilbert, Yann Leray and Nicolas Tabareau.</p>
          </div>
        </div>
        <div class="talk">
          <span class="time">11:30</span>
          <span class="speaker">Rémy Cerda and Alexis Saurin</span><br>
          <span class="title">Compression for Coinductive Infinitary Rewriting (A Preliminary Account)</span>
          <a class="show-abstract "href="javascript:toggle('abstract4')">(Abstract)</a><br>
          <div id="abstract4" class="abstract">
          <p>In “traditional” infinitary rewriting based on ordinal-indexed rewriting sequences and strong Cauchy convergence, a key property of rewriting systems is compression, that is, the fact that rewriting sequences of arbitrary ordinal length can be compressed to sequences of length ω. Famous examples of compressible systems are left-linear first-order systems and infinitary λ-calculi.
In this work, we investigate compression in the equivalent setting of coinductive infinitary rewriting, which we recall in a slightly augmented form: we extend it to rewriting of (possibly non-wellfounded) derivations in an arbitrary sytem of derivation rules. Then we define the coinductive counterpart of compressed rewriting sequences, and we present a general coinductive procedure turning arbitrary infinitary rewriting derivations into compressed ones, without relying on convergence. The coinductive presentation of the two aforementioned examples are endowed with compression lemmas as instances of our general method.</p>
          </div>
        </div>
        <div class="talk">
          <span class="time">12:00</span>
          <span class="speaker">Valentin Pasquale and Álvaro García-Pérez</span><br>
          <span class="title">Towards the type safety of Pure Subtype Systems</span>
          <a class="show-abstract "href="javascript:toggle('abstract4b')">(Abstract)</a><br>
          <div id="abstract4b" class="abstract">
          <p>We reformulate the open problem of type safety in Hutchins’ Pure
Subtype Systems (PSS) by proving it under a different conjecture. PSS
(hereafter in the singular) harmoniously mixes terms and types, thus
enabling a number of advanced language features that combine dependent
types with higher-order subtyping. In PSS, terms and types belong to the
same kind (everything is a subtype) and the resulting theory is based on
subtyping. However, conflating terms and types results in high
impredicativity and complicates PSS meta-theory. The crucial property of
type safety in PSS hinges on the well-known problem of transitivity
elimination. Despite Hutchins’ attempts, he failed to prove a key
commutativity property, and type safety has remained an open problem for
more than a decade. We introduce a reformulation of Hutchins’ PSS,
which we name Machine-Based Pure Subtype System (MPSS), which is based
on a mechanism reminiscent of the Krivine Abstract Machine, where the
proof of transitivity elimination is direct. Alas, in our MPSS,
subtyping is scope-dependent and type safety rests on the conjecture
that subtyping is congruent with covariant contexts. Our reformulation
of type safety in PSS uncovers a dilemma about a
commutativity/congruence problem, which sheds new light on possible
solutions and evidences the difficulty of the challenge proposed by
Hutchins.</p>
          </div>
        </div>
        <div class="break">
          <span class="time">12:30&ndash;14:00</span> Lunch Break
        </div>
        <div class="session">
        <span class="time">14:00&ndash;15:30</span> Session 3
        </div>
        <div class="talk">
          <span class="time">14:00</span>
          Invited talk: <span class="speaker">Vincent van Oostrom</span><br>
          <span class="title">Accounting for the cost of substitution in structured rewriting</span>
          <a class="show-abstract "href="javascript:toggle('abstract5')">(Abstract)</a><br>
          <div id="abstract5" class="abstract">
<p>
  We are interested in the cost of evaluating functional programs
  implemented by means of rewriting,
  be it higher- or first-order term rewriting or graph rewriting.
  Our starting observation is that in such <em>structured</em> rewrite systems
  the cost of <em>matching</em> exhibiting a redex-pattern, and 
  of <em>substitution</em> plugging-in the right-hand, is an
  <em>a priori</em> non-neglible part of the cost of a rewrite step.
  To account for that cost we propose to decompose
  rewrite steps into 3 stages: matching, replacement, and substitution,
  with the 1st and 3rd stages themselves consisting of rewrite steps
  in a so-called <em>Substitution Calculus</em> (SC).
  More precisely, 
  in a structured rewrite system, a rewrite step from a structure s to a structure
  t arises as C[&rho;] : C[l] &rarr; C[r] for some structure C[x] and rule &rho; : l &rarr; r
  by <em>substituting</em> the rule symbol &rho; respectively the structures l and r for x in C[x].
  For instance, in the case of higher-order term rewriting, rewrite steps invoke <em>higher-order</em>
  substitutions for both the <em>matching</em> and <em>substitution</em> stages.
  To get a hold on the cost of a rewrite step in structured rewriting,
  we propose substitution be made explicit leading to the rewrite step C[&rho;]
  being decomposed into s <sub>SC</sub>&Larr; C[l] &rarr; C[r] &Rarr;<sub>SC</sub> t
  for some substitution calculus SC,
  with the cost of the step being the sum of the costs of its 3 stages:
  <ol>
    <li> the <em>matching</em> phase, the SC-expansion s <sub>SC</sub>&Larr; C[l] exhibiting the to-be-replaced substructure l within s;
    <li> the <em>replacement</em> C[l] &rarr; C[r] of l by r according to rule &rho;;
    <li> the <em>substitution</em> phase, the SC-reduction C[r] &Rarr;<sub>SC</sub> t plugging-in the substructure r yielding t.
  </ol>
  We exemplify this idea for higher-order term rewrite systems (HRSs; having the simply typed &lambda;&alpha;&beta;&eta;-calculus as SC), for first-order
  term rewrite systems (TRSs; having an SC based on letrec), for term graph rewrite systems (TGRSs; having an SC, the &#x0436;-calculus, based on
  sharing) and for port-graph rewrite systems (PGRSs; having an SC based on indirection).
</p>
<p>
  The decomposition allows to investigate whether the cost of the SC-steps in stages 1 and 3 can be accounted for by the
  replacement step in stage 2, and / or  whether SC-steps themselves are unit cost or need to be decomposed further, in a given structured rewrite system.
  We illustrate this for the archetypical second-order HRS of beta-steps in the lambda-calculus.
  We show that of three well-known notions of beta-reduction: weak, leftmost&ndash;outermost, and multistep,
  the cost of the SC-steps <em>is</em> neglible for weak and leftmost&ndash;outermost beta, but is <em>not</em> neglible for multistep beta:
  <ul>
  <li>
    For weak and leftmost&ndash;outermost beta-reduction the substitutions to be performed
    are essentially first-order, suggesting one can implement both by TRSs.
    Further observing that TRS-steps are not unit cost (due to replication being built-in in its SC),
    we then further implement TRSs by TGRSs.
    Rewrite steps of the latter being <em>obviously</em> unit cost allows us then (by some careful reasoning)
    to conclude the same for weak and leftmost&ndash;outermost beta.
  <li>
    That is then contrasted to that multistep beta-reduction is not unit cost. 
    We base ourselves on the known fact that reaching a normal form is <em>much</em>
    more costly than the number of multistep betas needed to reach that normal form,
    entailing that the cost of substitution must be <em>high</em> (as difference between the former and the latter).
    We illustrate this phenomenon for an implementation of multistep beta by means of a PGRS,
    decomposing every multistep beta into: 
    4 SC-expansion steps of size 1, 1 replacement step of size 4,
    followed by a number of SC-reduction steps, a number that necessarily must be <em>large</em>, and indeed is large as we demo.
  </ul>
</p>
          </div>
        </div>
        <div class="talk">
          <span class="time">15:00</span>
          <span class="speaker">Enno Folkerts</span><br>
          <span class="title">Constructing a Curry Algebra where Indeterminates are not Left Cancellative</span>
          <a class="show-abstract "href="javascript:toggle('abstract6')">(Abstract)</a><br>
          <div id="abstract6" class="abstract">
          The origin of this extended abstract is the question which property of universal algebra is best suited to model the
role of free variables in term models of the lambda calculus.
In some mathematical contexts variables and indeterminates are just the same thing.
In this paper however, a variable is a term that can be turned into a semantic object when considering term models.
Indeterminates on the other hand are defined by a universal property and purely semantical objects.
The main result of this paper is the identification of a central property of universal algebra that holds for variables in the typical term models
while we construct a combinatory algebra where this property does not hold for indeterminates.
          </div>
        </div>
        <div class="break">
          <span class="time">15:30&ndash;16:00</span> Coffee Break
        </div>
        <div class="session">
        <span class="time">16:00&ndash;17:30</span> Session 4
        </div>
        <div class="talk">
          <span class="time">16:00</span> 
          Invited talk: <span class="speaker">Damiano Mazza</span><br>
          <span class="title">Revisiting Honda and Laurent's Correspondence between the Pi-Calculus and Linear Logic</span>
          <a class="show-abstract "href="javascript:toggle('abstract7')">(Abstract)</a><br>
          <div id="abstract7" class="abstract">
<p>In the late 2000s Honda and Laurent found an interesting correspondence
between the (asynchronous, local, internal) pi-calculus and a variant of
(polarized) linear logic proof nets.  Ehrhard and Laurent later
understood that these were in fact differential proof nets, that is,
proofs for an extension of linear logic called differential linear
logic.  This logical system admits cut-elimination, thus yielding what
looks like a concurrent version of the Curry-Howard correspondence.
Unfortunately, such a correspondence is imperfect: in Ehrhard and
Regnier's original formulation, which is the one considered by Ehrhard
and Laurent, the non-determinism of differential proof nets is incapable
of soundly matching the non-determinism of the pi-calculus (technically,
the natural rewriting systems associated with proof nets and with
processes are not bisimilar).</p>
<p>In the meantime, Caires and Pfenning introduced their own concurrent
version of the Curry-Howard correspondence, using plain linear logic on
one side and the session-typed pi-calculus on the other.  The work of
Honda, Laurent and Ehrhard was sort of eclipsed by the success of this
correspondence, and was not pursued any further.</p>
<p>It never occurred to anyone (including, until recently, myself) that,
rather than pointing out some insurmountable fundamental gap, the
failure of the first correspondence is simply suggesting that Ehrhard
and Regnier's cut-elimination rules for differential linear logic should
be changed.  Although it is still unclear (especially to myself) to what
extent this idea may be developed, it has already led to a couple of
interesting applications of linear-logical techniques to the
pi-calculus.  It also improved our (or, at least, my) understanding of
the relationship between Honda and Laurent's and Caires and Pfenning's
correspondences.  Albeit still difficult to formalize technically (at
least for me), the relationship is much tighter than what it looks like
at first sight (at least my sight).</p>
<p>I will explain how the pi-calculus suggests alternative cut-elimination
rules for differential linear logic, essentially rediscovering Honda and
Laurent's proof nets, but with a different syntax and backed up by the
solid semantic foundations provided by differential linear logic.  From
there, I will introduce the applications I mentioned above, namely
intersection types for the pi-calculus (a joint work with Dal Lago, de
Visme and Yoshimizu published a few years ago) and a work in progress
with Jaramillo and Perez in which we develop a type system enforcing
deadlock-freedom for a very expressive session-typed pi-calculus.  Along
the way, and if time allows it, I will try to give my understanding of
the kinship between Honda and Laurent's and Caires and Pfenning's
concurrent versions of Curry-Howard.</p>
          </div>
        </div>
        <div class="talk">
          <span class="time">17:00</span>
          <span class="speaker">Alejandro Diaz-Caro, Gilles Dowek and Jean-Pierre Jouannaud</span><br>
          <span class="title">Proving Termination With CPO</span>
          <a class="show-abstract "href="javascript:toggle('abstract8')">(Abstract)</a><br>
          <div id="abstract8" class="abstract">
<p>A popular, effective simplification ordering for proving termination of rewrite rules in a first-order setting is Dershowitz' recursive path ordering (RPO). Its higher-order generalization, the computability path ordering (CPO) by Blanqui, Jouannaud and Rubio is as effective, but much less popular. In this paper, we show that it can indeed be used in practice to save lots of complex termination arguments. Our examples originate from a recent proposal of the first two authors using a natural deduction style to describe quantum computations.</p>
          </div>
        </div>
    </div>

    <div class="section">
        <h2><a name="committees">Committees</a></h2>

        <h3>Programme Committee:</h3>
        <ul>
        <li> <a href="https://ix.cs.uoregon.edu/~ariola/">Zena Ariola</a> &ndash; University of Oregon, United States
        <li> <a href="https://public.lmf.cnrs.fr/~blsk/">Thibaut Balabonski</a> &ndash; Université Paris-Saclay, France
        <li> <a href="https://foones.github.io">Pablo Barenbaum</a> (chair) &ndash; Universidad Nacional de Quilmes &amp; Universidad de Buenos Aires, Argentina
        <li> <a href="http://www.ii.uni.wroc.pl/~mabi/">Małgorzata Biernacka</a> &ndash; University of Wroclaw, Poland
        <li> <a href="https://people.bath.ac.uk/wbh22/">Willem Heijltjes</a> &ndash; University of Bath, United Kingdom
        <li> <a href="https://www.imn.htwk-leipzig.de/~waldmann/index.html">Johannes Waldmann</a> &ndash; HTWK Leipzig, Germany
        </ul>

        <h3>Steering Committee:</h3>
        <ul>
        <li> <a href="https://www.irif.fr/~kesner/">Delia Kesner</a> &ndash; Universit&eacute; Paris Cit&eacute;, France
        <li> <a href="https://www.cs.vu.nl/~femke/">Femke van Raamsdonk</a> &ndash; Vrije Universiteit Amsterdam, The Netherlands
        </ul>
    </div>
</div>

<footer>
    12th International Workshop on Higher-Order Rewriting | Contact: <a href="https://foones.github.io">Pablo Barenbaum</a>
</footer>

</body>
</html>
